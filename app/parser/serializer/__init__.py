import datetime
from collections import OrderedDict

from app.parser.serializer.fields import Field, ValidationError, TimestampField


class InvalidSerializer(Exception):
    """Raised whenever serializer configuration is not valid"""
    pass


class SerializerData:
    """
    Class containing the results of calling ``Serializer.parse()``
    """

    _field_names = ()
    _ignored_fields = ()

    def __init__(self, values):
        """Constructor

        :param list values: list of values in the same order as
            ``_field_names``
        """
        self.__dict__['_lookup_dict'] = dict(zip(self._field_names, values))

    def __getattr__(self, item):
        try:
            return self._lookup_dict[item]
        except KeyError:
            raise AttributeError("This SerializerData object has no "
                                 "field '{}'".format(item))

    def __setattr__(self, key, value):
        # Only allow to set predefined fields
        if key not in self._field_names:
            raise AttributeError("This SerializerData object has no "
                                 "field '{}'".format(key))
        self._lookup_dict[key] = value

    def __contains__(self, item):
        return item in self._field_names

    def as_dict(self, fields=None, include_none=False):
        """Return data stored in this object as field name -> value dictionary

        :param list|tuple fields: list of fields to include in the dictionary.
            By default, the function returns all fields with
            ``dict_included=True``.
        :param bool include_none: whether or not ``None`` values should be
            included in the dictionary
        :return: dictionary with stored data
        :rtype: dict
        """
        result = {}
        if fields is None:
            fields = self._dict_included

        for field in self._field_names:
            if field not in fields:
                continue
            try:
                value = self._lookup_dict[field]
                if value is not None or include_none:
                    result[field] = value
            except KeyError:
                # Optional field, do nothing
                pass
        return result


class SerializerMetaclass(type):
    """
    Metaclass used in :py:class:`Serializer` class that gets all defined fields
    and generates data used later during parsing (i.e. moves the fields to
    a separate dictionary, creates list of fields to be included in dictionary
    generated by ``SerializerData.as_dict()`` as well as creates a subclass
    of :py:class:`SerializerData` itself).
    """

    @staticmethod
    def __new__(mcs, name, bases, attrs):
        fields = OrderedDict()
        dict_included = []
        optional_count = 0

        # Move declared fields to 'fields' attribute
        for key, attr in list(attrs.items()):
            if isinstance(attr, Field):
                fields[key] = attr
                attrs.pop(key)

                if attr.optional:
                    optional_count += 1
                elif optional_count > 0:
                    # Optional fields not at the end
                    raise InvalidSerializer('Encountered a non-optional field '
                                            'after one or more optional '
                                            'fields: {}'.format(key))

                if attr.dict_included:
                    dict_included.append(key)

        attrs['fields'] = fields
        attrs['optional_count'] = optional_count
        attrs['data_cls'] = type(name + 'Data', (SerializerData,),
                                 {'_field_names': list(fields.keys()),
                                  '_dict_included': dict_included})

        new_cls = super().__new__(mcs, name, bases, attrs)
        return new_cls

    @classmethod
    def __prepare__(mcs, cls, bases):
        # We want to get class fields in the original order
        return OrderedDict()


class BaseSerializer:
    fields = OrderedDict()
    """Dictionary containing serializer fields"""
    optional_count = 0
    """Number of optional fields at the end"""
    data_cls = SerializerData
    """Class to returned parsed data in"""

    separator = ','
    """Separator of fields used in ``get_data()``"""

    def parse_data(self, line_content, probe_start_time):
        """Parse individual fields taken from ``get_data(line_content)``

        :param str line_content: line of output as string
        :param datetime.datetime probe_start_time: datetime of probe software
            start; used to create values in TimestampFields
        :return: parsed data
        """
        data = self.get_data(line_content)
        vals = []

        # Check the number of fields
        if (len(data) < len(self.fields) - self.optional_count or
                len(data) > len(self.fields)):
            field_count = len(self.fields)
            if self.optional_count != 0:
                field_count = ('between {} and {}'
                               .format(field_count - self.optional_count,
                                       field_count))
            raise ValidationError('Number of fields parsed ({}) is not equal '
                                  'to the number of fields declared ({})'
                                  .format(len(data), field_count))

        # Parse data
        id = 1
        for (name, field), value in zip(self.fields.items(), data):
            try:
                if isinstance(field, TimestampField):
                    # Handle TimestampFields separately
                    val = (probe_start_time + datetime.timedelta(
                        milliseconds=field.get_value(value)))
                else:
                    val = field.get_value(value)
                vals.append(val)
            except ValidationError as e:
                # Set field name for better error messages
                e.field = name
                e.field_id = id
                raise
            id += 1

        data = self.data_cls(vals)
        self.post_parse_data(data)
        return data

    def get_data(self, line_content):
        """Split data from line_content as list of separate fields

        By default, the function returns line_content split by self.separator
        without the first value (which is assumed to be message type ID)

        :param str line_content: data as string
        :rtype: list
        """
        return line_content.split(self.separator)[1:]

    def post_parse_data(self, data):
        """Invoked when all fields are parsed

        Default implementation does nothing with the data. Subclasses may
        override it to e.g. calculate some value using multiple fields.

        :param data: parsed data, can be changed inside the method
        """
        pass

    @classmethod
    def get_collector_data(cls, data):
        """Return data that should be added to a Collector

        :param data: parsed data, may not be changed inside the method
        :return: dict of key-value mappings of data that should be added to the
            Collector instance (see
            :py:method:`app.analyzer.collector.Collector.add_value`)
        :rtype: dict|None
        """
        pass

    def parse(self, line_content, probe_start_time):
        """Parse given line of output

        Default implementation calls ``self.parse_data(line_content)``.
        Subclasses may override it for more sophisticated processing of data.

        :param str line_content: line of output as string
        :param datetime.datetime probe_start_time: datetime of probe software
            start; used to create values in TimestampFields
        :return: parsed data
        """
        return self.parse_data(line_content, probe_start_time)


class Serializer(BaseSerializer, metaclass=SerializerMetaclass):
    """
    Parser of specific format of data.

    Subclasses should provide fields to parse as class attributes. Valid types
    of fields are defined in ``fields`` module.

    Subclasses may also override ``get_data``, ``post_parse_data`` and
    ``parse`` to provide more advanced parsing and validation of data.
    """
    pass
